public class BST<T> {
	
	BSTNode<T> root,current;
	
	public BST() {
		root = current = null;
	}
	
	public boolean empty() {
		return root == null;
	}
	
	public boolean full() {
		return false;
	}
	
	public T retrieve() {
		return current.data;
	}
	
	public void update(T val) {
		current.data = val;
	}
	
	public boolean findKey(int tkey) {
		BSTNode<T> p,q;
		p = root;
		q = root;
		
		if(empty())
			return false;
		
		while(p != null) {
			q = p;
			
			if(p.key == tkey) {
				current = p;
				return true;
			}
			
			else if(tkey < p.key)
				p = p.left;
			else
				p = p.right;
		}
		current = q;
		return false;
	}
	
	public boolean insert(int k, T val) {
		BSTNode<T> p = current, q = current;
		
		if(findKey(k)) {
			current = q;  
			return false; 
		}
		
		p = new BSTNode<T>(k, val);
		if (empty()) {
			root = current = p;
			return true;
		}
		else {
			
			if (k < current.key)
				current.left = p;
			else
				current.right = p;
			current = p;
			return true;
		}
	}
	
	public boolean remove_key (int tkey){
		BooleanWrapper removed = new BooleanWrapper(false);
			BSTNode<T> p;
			p = remove_aux(tkey, root, removed);
			current = root = p;
			return removed.get();
	}
	
	private BSTNode<T> remove_aux(int key, BSTNode<T> p, BooleanWrapper flag) {
		BSTNode<T> q, child = null;
		if(p == null)
			return null;
		if(key < p.key)
			p.left = remove_aux(key, p.left, flag); 
		else if(key > p.key)
			p.right = remove_aux(key, p.right, flag); 
		else {
			flag.set( true);
			if (p.left != null && p.right != null){ 
				q = find_min(p.right);
				p.key = q.key;
				p.data = q.data;
				p.right = remove_aux(q.key, p.right, flag);
			}
			
			else {
				if (p.right == null) 
					child = p.left;
				else if (p.left == null) 
					child = p.right;
				return child;
			}
		}
		return p;
	}


	private BSTNode<T> find_min(BSTNode<T> p){
		if(p == null)
			return null;
		
		while(p.left != null){
			p = p.left;
		}
		
		return p;
	}

	
	
}
